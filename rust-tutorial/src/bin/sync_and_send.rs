/*
Sync と Send トレイト（Rustの並行性の基盤）

この節は、Rustの並行性で中核になるマーカートレイト Send と Sync を解説しています。どちらも標準ライブラリ（std::marker）にあり、型がマルチスレッドで「安全に使えるか」をコンパイル時に判断するための印（トレイト）です。

Send：所有権を別スレッドへ「送れる」か

Sendを実装する型は、値の所有権を他のスレッドへ安全に転送できます。ほとんどの型はSendですが、例外として Rc<T> はSendではありません。理由は参照カウントの更新が原子的でなく、複数スレッドから同時更新され得るためです。並行用途では Arc<T>（原子的な参照カウント）が推奨されます。実際、前章の例でも Rc<Mutex<i32>> はエラーになり、 Arc<Mutex<i32>> に置き換えるとコンパイル成功しました。

Sync：複数スレッドから「参照しても安全」か

Syncを実装する型は、同じ値への参照（&T）が複数スレッドに共有されても安全です。言い換えると「&T が Send なら T は Sync」です。基本型はSyncで、Syncな部品だけで構成される型もSyncになります。ここでも Rc<T> や RefCell<T>/Cell<T> はSyncではありません。RefCellの「実行時借用チェック」はスレッドセーフでないためです。一方、Mutex<T> はSyncで、複数スレッドからの安全な共有に使えます。

手動実装はunsafeで注意が必要

Send/Syncは通常「自動導出」されるため、手で実装する必要はありません。もし非Sync/非Sendな部品を含む新型に対して手動で付与するなら、unsafe な知識と厳密な不変条件の理解が不可欠です。詳細は「Rustonomicon」にまとまっています。

まとめと実務の指針
 • スレッドへ値を渡すなら型が Send か確認する。共有なら型が Sync か確認する。
 • 参照カウントの共有は Arc を使い、内部の可変は Mutex などの同期原語で守る。
 • Rc/RefCell はシングルスレッド向け、Arc/Mutex はマルチスレッド向けという整理が実務的。
 */

fn main() {
    println!("Sync and Send trait sample in Rust");
}